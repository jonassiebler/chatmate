package cmd

import (
	"os"
	"testing"

	"github.com/spf13/cobra"
)

// TestTutorialCommand tests tutorial command functionality
func TestTutorialCommand(t *testing.T) {
	// Find tutorial command
	var tutorialCmd *cobra.Command
	commands := rootCmd.Commands()
	for _, cmd := range commands {
		if cmd.Name() == "tutorial" {
			tutorialCmd = cmd
			break
		}
	}

	if tutorialCmd == nil {
		t.Fatal("Tutorial command not found")
	}

	// Test basic properties
	if tutorialCmd.Short == "" {
		t.Error("Tutorial command should have short description")
	}

	// Test execution if RunE exists
	if tutorialCmd.RunE != nil {
		// Capture output
		old := os.Stdout
		os.Stdout = os.NewFile(0, os.DevNull)
		defer func() { os.Stdout = old }()

		err := tutorialCmd.RunE(tutorialCmd, []string{})
		if err != nil {
			t.Logf("Tutorial command execution completed: %v", err)
		}
	}
}

// TestVersionCommand tests version command functionality
func TestVersionCommand(t *testing.T) {
	// Version command should be automatically generated by Cobra
	commands := rootCmd.Commands()
	found := false
	for _, cmd := range commands {
		if cmd.Name() == "version" {
			found = true
			break
		}
	}

	if !found {
		t.Error("Version command should exist")
	}
}

// TestCompletionCommand tests completion command functionality
func TestCompletionCommand(t *testing.T) {
	// Find completion command
	var completionCmd *cobra.Command
	commands := rootCmd.Commands()
	for _, cmd := range commands {
		if cmd.Name() == "completion" {
			completionCmd = cmd
			break
		}
	}

	if completionCmd == nil {
		t.Fatal("Completion command not found")
	}

	// Test that it has valid shell arguments instead of subcommands
	if len(completionCmd.ValidArgs) == 0 {
		t.Error("Completion command should have valid shell arguments")
	}

	expectedShells := []string{"bash", "zsh", "fish", "powershell"}
	for _, shell := range expectedShells {
		found := false
		for _, validArg := range completionCmd.ValidArgs {
			if validArg == shell {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("Expected shell %s not found in ValidArgs", shell)
		}
	}
}

// TestGlobalFlags tests global flag functionality
func TestGlobalFlags(t *testing.T) {
	// Test verbose flag
	verboseFlag := rootCmd.PersistentFlags().Lookup("verbose")
	if verboseFlag == nil {
		t.Fatal("Verbose flag should exist")
	}

	// Test flag properties
	if verboseFlag.Usage == "" {
		t.Error("Verbose flag should have usage text")
	}

	if verboseFlag.DefValue != "false" {
		t.Errorf("Verbose flag default should be false, got %s", verboseFlag.DefValue)
	}
}

// TestCommandHelp tests help functionality for all commands
func TestCommandHelp(t *testing.T) {
	commands := []*cobra.Command{rootCmd, hireCmd, listCmd, statusCmd, configCmd, uninstallCmd}

	for _, cmd := range commands {
		if cmd == nil {
			continue
		}

		t.Run(cmd.Name(), func(t *testing.T) {
			// Test that command has some help text
			if cmd.Short == "" {
				t.Errorf("Command %s should have short help text", cmd.Name())
			}

			// Test that complex commands have detailed help
			if cmd.Name() == "hire" || cmd.Name() == "list" || cmd.Name() == "uninstall" {
				if cmd.Long == "" {
					t.Errorf("Command %s should have detailed help text", cmd.Name())
				}

				if cmd.Example == "" {
					t.Logf("Command %s could benefit from examples", cmd.Name())
				}
			}
		})
	}
}

// TestCommandFlags tests that all commands have proper flag definitions
func TestCommandFlags(t *testing.T) {
	testCases := []struct {
		cmd           *cobra.Command
		name          string
		expectedFlags []string
	}{
		{hireCmd, "hire", []string{"force", "specific"}},
		{listCmd, "list", []string{"available", "installed"}},
		{uninstallCmd, "uninstall", []string{"all"}},
	}

	for _, tc := range testCases {
		if tc.cmd == nil {
			continue
		}

		t.Run(tc.name, func(t *testing.T) {
			for _, flagName := range tc.expectedFlags {
				flag := tc.cmd.Flags().Lookup(flagName)
				if flag == nil {
					t.Errorf("Command %s should have flag --%s", tc.name, flagName)
				}
			}
		})
	}
}
